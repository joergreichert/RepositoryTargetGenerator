/*
 * generated by Xtext
 */
package de.abg.jreichert.ui.contentassist;

import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.jface.dialogs.ProgressMonitorDialog;
import org.eclipse.jface.operation.IRunnableWithProgress;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.jface.viewers.StyledString;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.statushandlers.StatusManager;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.common.ui.contentassist.TerminalsProposalProvider;
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;

import com.google.inject.Inject;

import de.abg.jreichert.repositorytarget.xml.ContentJarParser;
import de.abg.jreichert.repositorytarget.xml.ContentXmlHandler;
import de.abg.jreichert.targetDefinition.Location;
import de.abg.jreichert.targetDefinition.Unit;
import de.abg.jreichert.ui.internal.TargetDefinitionActivator;

/**
 * see
 * http://www.eclipse.org/Xtext/documentation/latest/xtext.html#contentAssist on
 * how to customize content assistant
 */
public class TargetDefinitionProposalProvider extends
		AbstractTargetDefinitionProposalProvider {

	@Inject
	private TerminalsProposalProvider terminalsProposalProvider;

	private static String FEATURE_GROUP = ".feature.group";

	private Map<String, SortedMap<String, SortedSet<String>>> urlToCategoryIdsToVersions = new HashMap<String, SortedMap<String, SortedSet<String>>>();

	@Override
	public void completeUnit_CategoryId(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		StyledString displayString = null;
		ICompletionProposal proposal = null;
		Location location = getLocation(model);
		if (location != null) {
			String repositoryLocation = location.getRepositoryLocation();
			if (repositoryLocation != null) {
				try {
					fill(repositoryLocation);
					Set<String> ids = urlToCategoryIdsToVersions.get(
							repositoryLocation).keySet();
					for (String id : ids) {
						displayString = new StyledString(id);
						proposal = doCreateProposal(id, displayString, null, 0,
								context);
						acceptor.accept(proposal);
					}
				} catch (Exception exception) {
					IStatus status = new Status(
							IStatus.ERROR,
							TargetDefinitionActivator.DE_ABG_JREICHERT_TARGETDEFINITION,
							"Exception while parsing the content.xml",
							exception);
					StatusManager.getManager().handle(status,
							StatusManager.LOG | StatusManager.SHOW);
				}
			}
		}
	}

	private void fill(final String repositoryLocation)
			throws InvocationTargetException, InterruptedException {
		if (repositoryLocation != null) {
			if (urlToCategoryIdsToVersions.get(repositoryLocation) == null) {
				final ContentXmlHandler contentHandler = new ContentXmlHandler();
				IRunnableWithProgress runnable = new IRunnableWithProgress() {

					@Override
					public void run(IProgressMonitor monitor)
							throws InvocationTargetException,
							InterruptedException {
						try {
							monitor.beginTask(
									"Read out P2 repository metadata", 2);
							monitor.subTask("Fetch contents");
							final ContentJarParser parser = new ContentJarParser(
									repositoryLocation);
							List<String> contents = parser.getContents();
							monitor.worked(1);
							monitor.subTask("Parse contents (this could take up to one minute)");
							SubProgressMonitor subProgressMonitor = new SubProgressMonitor(
									monitor, 1);
							subProgressMonitor.beginTask(
									"Read out P2 repository metadata",
									contents.size());
							int i = 0;
							for (String content : contents) {
								subProgressMonitor.subTask("Parsing file " + i);
								parser.parse(content, contentHandler);
								subProgressMonitor.worked(i++);
							}
							monitor.done();
						} catch (java.lang.OutOfMemoryError ooe) {
							IStatus status = new Status(
									IStatus.ERROR,
									TargetDefinitionActivator.DE_ABG_JREICHERT_TARGETDEFINITION,
									"Out of memory: Please start your Eclipse with something like -Xmx1024m -Xms1024m -XX:MaxPermSize=512m",
									ooe);
							StatusManager.getManager().handle(status,
									StatusManager.LOG | StatusManager.SHOW);
						}
					}
				};
				Shell shell = Display.getDefault().getActiveShell();
				ProgressMonitorDialog dialog = new ProgressMonitorDialog(shell);
				dialog.run(true, true, runnable);
				urlToCategoryIdsToVersions.put(repositoryLocation,
						contentHandler.getIdToVersion());
			}
		}
	}

	private String getRepositoryLocation(Unit unit) {
		String repositoryLocation = null;
		Location location = (Location) unit.eContainer();
		if (location != null) {
			repositoryLocation = location.getRepositoryLocation();
		}
		return repositoryLocation;
	}

	private Unit getUnit(EObject model) {
		return getType(model, Unit.class);
	}

	private Location getLocation(EObject model) {
		return getType(model, Location.class);
	}

	@SuppressWarnings({ "unchecked" })
	private <T> T getType(EObject model, Class<T> clazz) {
		T type = null;
		if (clazz.isAssignableFrom(model.getClass())) {
			type = (T) model;
		}
		return type;
	}

	@Override
	public void completeUnit_Version(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		StyledString displayString = null;
		ICompletionProposal proposal = null;
		Unit unit = getUnit(model);
		if (unit != null) {
			String repositoryLocation = getRepositoryLocation(unit);
			if (repositoryLocation != null) {
				String categoryId = unit.getCategoryId();
				if (categoryId != null) {
					try {
						fill(repositoryLocation);
						categoryId = unit.isNoFeature()
								|| categoryId.endsWith(FEATURE_GROUP) ? categoryId
								: categoryId + ".feature.group";
						Set<String> versions = urlToCategoryIdsToVersions.get(
								repositoryLocation).get(categoryId);
						if (versions != null) {
							for (String version : versions) {
								if (version != null) {
									displayString = new StyledString(version);
									proposal = doCreateProposal(version,
											displayString, null, 0, context);
									acceptor.accept(proposal);
								}
							}
						}
					} catch (Exception exception) {
						IStatus status = new Status(
								IStatus.ERROR,
								TargetDefinitionActivator.DE_ABG_JREICHERT_TARGETDEFINITION,
								"Exception while parsing the content.xml",
								exception);
						StatusManager.getManager().handle(status,
								StatusManager.LOG | StatusManager.SHOW);
					}
				}
			}
		}
	}

	@Override
	public void complete_URL(EObject model, RuleCall ruleCall,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		String exampleUrl = "http://www.example.org/p2";
		StyledString displayString = new StyledString(exampleUrl);
		ConfigurableCompletionProposal proposal = doCreateProposal(exampleUrl,
				displayString, null, 0, context);
		acceptor.accept(proposal);
	}

	@Override
	public void complete_STRING(EObject model, RuleCall ruleCall,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		terminalsProposalProvider.complete_STRING(model, ruleCall, context,
				acceptor);
	}

	@Override
	public void complete_ID(EObject model, RuleCall ruleCall,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		if (EcoreUtil2.getContainerOfType(model, Location.class) == null) {
			terminalsProposalProvider.complete_ID(model, ruleCall, context,
					acceptor);
		} else {
			super.complete_ID(model, ruleCall, context, acceptor);
		}
	}
}
