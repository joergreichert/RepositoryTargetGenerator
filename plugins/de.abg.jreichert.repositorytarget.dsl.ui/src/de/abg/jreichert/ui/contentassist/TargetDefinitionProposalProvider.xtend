/*
 * generated by Xtext
 */
package de.abg.jreichert.ui.contentassist

import com.google.inject.Inject
import de.abg.jreichert.repositorytarget.xml.ContentJarParser
import de.abg.jreichert.repositorytarget.xml.ContentXmlHandler
import de.abg.jreichert.targetDefinition.Location
import de.abg.jreichert.targetDefinition.Unit
import de.abg.jreichert.ui.internal.TargetDefinitionActivator
import java.lang.reflect.InvocationTargetException
import java.util.SortedMap
import java.util.SortedSet
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.core.runtime.IStatus
import org.eclipse.core.runtime.Status
import org.eclipse.core.runtime.SubProgressMonitor
import org.eclipse.emf.ecore.EObject
import org.eclipse.jface.dialogs.ProgressMonitorDialog
import org.eclipse.jface.operation.IRunnableWithProgress
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.eclipse.jface.viewers.StyledString
import org.eclipse.swt.widgets.Display
import org.eclipse.ui.statushandlers.StatusManager
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.common.ui.contentassist.TerminalsProposalProvider
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

/**
 * see http://www.eclipse.org/Xtext/documentation/latest/xtext.html#contentAssist on how to customize content assistant
 */
class TargetDefinitionProposalProvider extends AbstractTargetDefinitionProposalProvider {

	@Inject
	private TerminalsProposalProvider terminalsProposalProvider

	private static String FEATURE_GROUP = ".feature.group"

	private val urlToCategoryIdsToVersions = <String, SortedMap<String, SortedSet<String>>>newHashMap

	override complete_URL(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val exampleUrl = "http://www.example.org/p2"
		val displayString = new StyledString(exampleUrl)
		val proposal = doCreateProposal(exampleUrl, displayString, null, 0, context)
		acceptor.accept(proposal)
	}

	override completeUnit_CategoryId(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val location = getLocation(model)
		if (location != null) {
			val repositoryLocation = location.getRepositoryLocation()
			if (repositoryLocation != null) {
				var StyledString displayString = null
				var ICompletionProposal proposal = null
				try {
					fill(repositoryLocation)
					val ids = urlToCategoryIdsToVersions.get(repositoryLocation).keySet()
					for (String id : ids) {
						displayString = new StyledString(id)
						proposal = doCreateProposal(id, displayString, null, 0, context)
						acceptor.accept(proposal)
					}
				} catch (Exception exception) {
					val status = new Status(IStatus::ERROR,
						TargetDefinitionActivator::DE_ABG_JREICHERT_TARGETDEFINITION,
						"Exception while parsing the content.xml", exception)
					StatusManager::getManager().handle(status, StatusManager::LOG.bitwiseOr(StatusManager::SHOW))
				}
			}
		}
	}

	def private Location getLocation(EObject model) {
		return getType(model, typeof(Location))
	}

	def private <T> T getType(EObject model, Class<T> clazz) {
		var T type = null
		if (clazz.isAssignableFrom(model.getClass())) {
			type = model as T
		}
		return type
	}

	def private void fill(String repositoryLocation) throws InvocationTargetException, InterruptedException {
		if (repositoryLocation != null) {
			if (urlToCategoryIdsToVersions.get(repositoryLocation) == null) {
				val contentHandler = new ContentXmlHandler()
				val runnable = new ReadOutP2RepositoryRunnable(repositoryLocation, contentHandler)
				val shell = Display::getDefault().getActiveShell()
				val dialog = new ProgressMonitorDialog(shell)
				dialog.run(true, true, runnable)
				urlToCategoryIdsToVersions.put(repositoryLocation, contentHandler.getIdToVersion())
			}
		}
	}

	override completeUnit_Version(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val Unit unit = getUnit(model)
		if (unit != null) {
			val repositoryLocation = getRepositoryLocation(unit)
			if (repositoryLocation != null) {
				var categoryId = unit.getCategoryId()
				if (categoryId != null) {
					var StyledString displayString = null
					var ICompletionProposal proposal = null
					try {
						fill(repositoryLocation)
						categoryId = if(unit.isNoFeature() || categoryId.endsWith(FEATURE_GROUP)) categoryId else categoryId +
							".feature.group"
						val versions = urlToCategoryIdsToVersions.get(repositoryLocation).get(categoryId)
						if (versions != null) {
							for (String version : versions) {
								if (version != null) {
									displayString = new StyledString(version)
									proposal = doCreateProposal(version, displayString, null, 0, context)
									acceptor.accept(proposal)
								}
							}
						}
					} catch (Exception exception) {
						val status = new Status(IStatus::ERROR,
							TargetDefinitionActivator::DE_ABG_JREICHERT_TARGETDEFINITION,
							"Exception while parsing the content.xml", exception)
						StatusManager::getManager().handle(status,
							StatusManager::LOG.bitwiseOr(StatusManager::SHOW))
					}
				}
			}
		}
	}

	def private Unit getUnit(EObject model) {
		return getType(model, typeof(Unit))
	}

	def private String getRepositoryLocation(Unit unit) {
		var String repositoryLocation = null
		val location = unit.eContainer() as Location
		if (location != null) {
			repositoryLocation = location.getRepositoryLocation()
		}
		return repositoryLocation
	}

	override complete_STRING(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		terminalsProposalProvider.complete_STRING(model, ruleCall, context, acceptor)
	}

	override complete_ID(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (EcoreUtil2::getContainerOfType(model, typeof(Location)) == null) {
			terminalsProposalProvider.complete_ID(model, ruleCall, context, acceptor)
		} else {
			super.complete_ID(model, ruleCall, context, acceptor)
		}
	}
}

@Data
class ReadOutP2RepositoryRunnable implements IRunnableWithProgress {
	private val String repositoryLocation
	private val ContentXmlHandler contentHandler

	override run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
		try {
			monitor.beginTask("Read out P2 repository metadata", 2)
			monitor.subTask("Fetch contents")
			val parser = new ContentJarParser(repositoryLocation)
			val contents = parser.getContents()
			monitor.worked(1)
			monitor.subTask("Parse contents (this could take up to one minute)")
			val subProgressMonitor = new SubProgressMonitor(monitor, 1)
			subProgressMonitor.beginTask("Read out P2 repository metadata", contents.size())
			var int i = 0
			for (String content : contents) {
				subProgressMonitor.subTask("Parsing file " + i)
				parser.parse(content, contentHandler)
				subProgressMonitor.worked(i)
				i = i + 1
			}
			monitor.done()
		} catch (OutOfMemoryError ooe) {
			val status = new Status(IStatus::ERROR, TargetDefinitionActivator::DE_ABG_JREICHERT_TARGETDEFINITION,
				"Out of memory: Please start your Eclipse with something like -Xmx1024m -Xms1024m -XX:MaxPermSize=512m",
				ooe)
			StatusManager::getManager().handle(status, StatusManager::LOG.bitwiseOr(StatusManager::SHOW))
		}
	}
}
